# 工作证明
> 
>工作证明是使不可信方合法化的一种方式
> 
### 工作证明到底是什么？ ¶
工作证明是不可信方为了解决人工问题而使用大量计算资源的密码证明。
从技术上讲，“证明”是解决问题的一种方案。
### 这是为了让不可信任的一方合法化
一个互联网上的不受信任方如何赢得你的信任？
它可以通过解决公认很难的计算题来证明承诺。
例如，通过要求不受信任的一方在接受其连接之前执行硬计算，您将连接仅限于“已允许”的一方。
在另一个示例中，您可以要求将 PoW 附加到传入的电子邮件，从而使发送垃圾邮件代价变得昂贵。
### 除此之外，工作一定是无用的
关于“计算难题”的工作和解决方案除了证明承诺之外没有任何其他用处。
如果这份工作在其他地方有用，那么它就不能证明对你的承诺。
这个问题肯定是人为的。 否则，激励机制就会扭曲，整个计划就会失败。
### 强烈的不对称性
工作方案的证明要求与验证资源有很强的不对称性。
这项工作一定会艰苦。 同时，证明验证必须保持非常廉价(在计算资源方面)。
成本较低的验证是至关重要的，因为在这个阶段，我们面对的是潜在的大量的不可信方，他们可以通过提交无效的证明来使验证者无法工作，这样的证明应该丢弃。

# 加密货币工作证明
> 
>工作证明是一个 Sybil 保护机制
> 
## 用POW来抵抗女巫攻击
在分布式加密货币中，不可信的参与者确认(块)事务。
如果采用门槛投票，那么该计划将立即中止。 这是因为没有任何东西可以阻止一个演员创造任意数量的假名并接管投票权。 在分布式系统中，这被称为女巫攻击。
相反，加密货币采用了工作证明。 在工作方案的论证中，重要的不是演员的数量，而是提交的计算资源量。
当然，这一点很难做到。 要破坏该方案的安全机制，攻击者必须实际控制大部分(50%)的计算资源。 在实践中，攻击者在相当长的一段时间内需要这种控制。
## 战俘是一种领导人选举机制
在分布式系统中，“领导者选举”是确定哪个节点负责(暂时)协调系统的过程。
在加密货币战俘是用来选择节点“赢得”下一个块。
用 PoW 进行领导人选举是比特币引入的关键创新之一。
相互竞争的节点(被称为“矿工”)致力于解决人为问题。 时不时地，总会有人找到解决办法。 机会与承诺的计算能力成线性关系。
获胜者使用其解决方案“承销”其组装的块。 网络只接受带有有效解决方案的块。
获胜者也会因其工作获得奖励。 奖励是“凭空创造”并分配给自己的一种特定数量的加密货币。 获胜者还可以从包含在块中的交易中获得所有费用。
Pow 问题的难度由网络动态调整，目标是找到具有大致恒定速率的块(通常每隔几分钟)。

# Cryptonight
> 
>Cryptonight 是一个内存硬散列函数
> 
## 背景
Cryptonight 最初设计于2013年，是 CryptoNote 套件的一部分。
其中一个设计目标是通过采用以下技术，使其对现成的 cpu 非常友好:
* 原生 AES 加密
* 快速64位乘法器
* 暂存器适合英特尔 cpu 上每核 L3缓存的大小(大约2 MB)

更加雄心勃勃的设计目标是让它在 asic 上无法有效地计算。 这个计划已经失败了，因为它不可避免地发生在“ ASIC 化”算法上。 高效的 CryptoNight ASIC 是由 Bitmain 在2017年开发的。
2014年，Monero 继承了 CryptoNight 作为其工作的证明。 从那时起，Monero 稍微改进了算法，故意破坏与发布的 ASIC-s 的兼容性。 目前 Monero 实现了 CryptoNight v2，这是 CryptoNight 的第三个迭代(v0、 v1、 v2)。
## 目标是找到足够小的散列
在基于哈希的 PoW 算法中，目标是找到足够小的哈希。
哈希只是一个整数(通常是一个非常大的整数)。 大多数散列函数生成256位散列(0到2 ^ 256之间的整数)。 这包括比特币的 double-SHA-256和 Monero 的 CryptoNight。
Miner 随机调整输入数据，直到散列符合指定的阈值。 阈值(也是一个大整数)作为一致性机制的一部分由网络集体建立。 Pow 只有在散列符合阈值的情况下才被认为是有效的(已解决)。
因为哈希函数是单向的，所以不可能通过分析计算会导致足够小的哈希的输入数据。 解决方案必须通过对输入数据进行调整和反复重新计算散列来强制执行。
矿工在输入数据方面有一些灵活性——最重要的是，他们可以使用 nonce 值进行迭代。 它们还可以控制哪些事务包含在块中，以及如何将它们放在默克尔树中。
## 加密原语
Cryptonight 是基于:
* Aes 加密

5个散列函数，所有这些函数都是 NIST SHA-3竞赛的决赛选手:
  * Keccak (主要的一个)
  * BLAKE
  * Groestl 
  * JH
  * Skein
*  
## 输入数据¶
在 Monero 中，哈希函数的输入是:
* 序列化的块头(大约46个字节; 使用 varint 表示)
* 默克尔树根(32字节)
* 块中包含的交易数(大约1-2个字节; 使用 varint 表示)

请参阅获取块哈希 blob ()函数来进一步挖掘。
## 算法¶
 
警告
 
本文试图让读者对 CryptoNight 算法有一个高水平的了解。 有关实现的细节，请参阅 CryptoNote 标准和 Monero 源代码。 请参阅底部的参考资料。
 
### 综述¶
Cryptonight 试图使内存访问成为性能(“内存硬度”)的瓶颈。 它有三个步骤:
1. 用伪随机数据初始化大面积内存。 这种记忆被称为暂存本。
2. 对暂存器上的伪随机(但是确定性的)地址执行大量的读 / 写操作。
3. 对整个暂存器进行哈希，以生成结果值。
### 第一步: 暂存器初始化
首先，用 Keccak-1600对输入数据进行哈希处理， 结果生成200字节的伪随机数据(1600比特200字节)。
这200个字节变成一个种子，通过应用 AES-256加密，生成一个更大的、2mb 宽的伪随机数据缓冲区。
Keccak-1600最开始的0..31字节被用作 AES 密钥。
对128个字节长的有效负载执行加密，直到2mb 准备就绪。 第一个有效载荷是 Keccak-1600 字节 66..91. 下一个有效负载是前一个有效负载的加密结果。
每个128字节的负载实际上被加密了10次。
详细信息稍微有些差别，请参阅 CryptoNote 标准中的“ 初始化暂存器”。
### 第二步: 内存硬循环
第二步基本上是简单有状态算法的524288次迭代。
每个算法迭代在伪随机但确定的位置读取并写回暂存器。
关键的是，下一次迭代取决于前一次迭代所准备的状态。 直接计算未来迭代的状态是不可能的。
具体的操作包括 AES、 XOR、8字节 mul、8字节的添加操作，这些操作对 cpu 非常友好(在现代 cpu 上进行了高度优化)。
这里的目标是使内存延迟成为瓶颈，试图缩小潜在的 ASIC-s 和通用 cpu 之间的差距。
### 第三步: 散列
最后一步(简化)是:
* 结合原 Keccak-1600输出与整个暂存器

根据结果的2个低阶比特选择哈希算法
  * 0= BLAKE-256
  * 1= Groestl-256
  * 2= JH-256
  * 3 =Skein-256
*  
* 使用选定函数对结果进行散列

生成的256位哈希是 CryptoNight 算法的最终输出。
## 特定的修改
### 1. 门罗币 v0
这就是 Monero 社区如何引用 CryptoNight 的实现。
### 门罗币 v 1
请参阅源代码 diff。
### 门罗币 v 2
查看基本原理和源代码差异。
### 3 aka CryptoNightR
查看基本原理和源代码差异。
## 评论¶
* 门罗币散列的验证成本相对较高。 这带来了一个风险，即 DoS-ing 节点需要处理不正确的证明。 看到强烈的不对称要求。
* 哈希函数是在有限的同行评审下从零开始设计的。 虽然 CryptoNight 是由经过验证和同行评审的原语组成的，但是结合安全原语并不一定会产生安全的密码系统。
* Cryptonight 最终未能阻止 ASIC-s。
* Cryptonight 的复杂性扼杀了 ASIC 制造业的竞争。

Cryptonight 的工作证明仍然是莫内罗最具争议的方面之一。
## Reference¶
* Cryptonote 标准中的 CryptoNight 散列函数描述

2源代码
  * 入口点是 cn slow hash()函数。 手动删除对多种体系结构的支持和优化应该有助于您理解实际的代码。
*  
* 秘密白皮书”工作的平等证明”章节
* 第一天的Monero挖矿作者: David Andersen 博士
* 莫内罗源代码中的一些测试向量


